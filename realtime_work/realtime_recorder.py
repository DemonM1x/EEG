import csv
import os
import time
from datetime import datetime
from typing import Optional, TextIO

from PyQt5.QtCore import QObject, pyqtSignal

from .realtime_driver import EEGSampleBatch


class RealtimeEEGRecorder(QObject):
    # Сигналы
    recording_started = pyqtSignal(str)  # путь к файлу
    recording_stopped = pyqtSignal(str)  # статистика записи
    error_occurred = pyqtSignal(str)  # ошибки

    def __init__(self):
        super().__init__()
        self.file_path: Optional[str] = None
        self.file_handle: Optional[TextIO] = None
        self.csv_writer: Optional[csv.writer] = None
        self.is_recording = False

        # Статистика
        self.samples_written = 0
        self.start_time = None
        self.file_size_bytes = 0

    def start_recording(self, file_path: str, include_timestamp: bool = True) -> bool:
        if self.is_recording:
            self.error_occurred.emit("Запись уже активна")
            return False

        try:
            # Создаем директорию если не существует
            os.makedirs(os.path.dirname(file_path), exist_ok=True)

            # Открываем файл для записи
            self.file_handle = open(file_path, 'w', newline='', encoding='utf-8')
            self.csv_writer = csv.writer(self.file_handle)

            # Записываем заголовок
            header = self._create_header(include_timestamp)
            self.csv_writer.writerow(header)

            # Записываем метаданные как комментарии
            self._write_metadata()

            self.file_path = file_path
            self.is_recording = True
            self.samples_written = 0
            self.start_time = time.time()
            self.file_size_bytes = 0

            self.recording_started.emit(file_path)
            return True

        except Exception as e:
            self.error_occurred.emit(f"Ошибка начала записи: {e}")
            self._cleanup()
            return False

    def stop_recording(self) -> bool:
        if not self.is_recording:
            return False

        try:
            # Записываем финальную статистику
            self._write_final_stats()

            # Закрываем файл
            if self.file_handle:
                self.file_handle.close()

            # Получаем размер файла
            if self.file_path and os.path.exists(self.file_path):
                self.file_size_bytes = os.path.getsize(self.file_path)

            # Формируем статистику
            duration = time.time() - self.start_time if self.start_time else 0
            stats = (
                f"Записано {self.samples_written} образцов за {duration:.1f}с. "
                f"Размер файла: {self.file_size_bytes / 1024:.1f} КБ"
            )

            self.recording_stopped.emit(stats)

            self._cleanup()
            return True

        except Exception as e:
            self.error_occurred.emit(f"Ошибка остановки записи: {e}")
            self._cleanup()
            return False

    def write_batch(self, batch: EEGSampleBatch) -> bool:
        if not self.is_recording or not self.csv_writer:
            return False

        try:
            for sample in batch.samples:
                # Формируем строку данных для одного канала
                row = [sample.timestamp]

                # Добавляем данные первого (единственного) канала
                if sample.amplitudes:
                    row.append(sample.amplitudes[0])
                else:
                    row.append(0.0)

                self.csv_writer.writerow(row)
                self.samples_written += 1

            # Принудительная запись на диск каждые 100 образцов
            if self.samples_written % 100 == 0:
                self.file_handle.flush()

            return True

        except Exception as e:
            self.error_occurred.emit(f"Ошибка записи данных: {e}")
            return False

    def _create_header(self, include_timestamp: bool) -> list:
        header = []

        if include_timestamp:
            header.append('timestamp')

        # Добавляем колонку для единственного канала
        header.append('channel_1')

        return header

    def _write_metadata(self):
        if not self.csv_writer:
            return

        metadata = [
            f"# EEG Recording Session",
            f"# Start Time: {datetime.now().isoformat()}",
            f"# Channels: 1",
            f"# Format: CSV with header",
            f"# Generated by EEG Analyzer Real-time Module",
            ""  # Пустая строка для разделения
        ]

        for line in metadata:
            self.csv_writer.writerow([line])

    def _write_final_stats(self):
        if not self.csv_writer or not self.start_time:
            return

        duration = time.time() - self.start_time

        stats = [
            "",  # Пустая строка
            f"# Recording Statistics:",
            f"# Duration: {duration:.2f} seconds",
            f"# Total Samples: {self.samples_written}",
            f"# Average Sample Rate: {self.samples_written / duration:.1f} Hz",
            f"# End Time: {datetime.now().isoformat()}"
        ]

        for line in stats:
            self.csv_writer.writerow([line])

    def _cleanup(self):
        self.is_recording = False
        self.file_path = None

        if self.file_handle:
            try:
                self.file_handle.close()
            except:
                pass
            self.file_handle = None

        self.csv_writer = None

    def get_recording_stats(self) -> dict:
        duration = 0
        sample_rate = 0

        if self.start_time and self.is_recording:
            duration = time.time() - self.start_time
            if duration > 0:
                sample_rate = self.samples_written / duration

        return {
            'is_recording': self.is_recording,
            'file_path': self.file_path,
            'samples_written': self.samples_written,
            'duration_seconds': duration,
            'sample_rate_hz': sample_rate,
            'file_size_bytes': self.file_size_bytes,
            'channels': 1
        }

    def is_recording_active(self) -> bool:
        return self.is_recording


class AutoSaveRecorder(RealtimeEEGRecorder):

    def __init__(self, auto_save_interval: int = 300):
        super().__init__()
        self.auto_save_interval = auto_save_interval  # секунды
        self.base_file_path = None
        self.file_counter = 1
        self.last_save_time = None

    def start_recording(self, base_file_path: str, include_timestamp: bool = True) -> bool:
        self.base_file_path = base_file_path
        self.file_counter = 1
        self.last_save_time = time.time()

        # Создаем первый файл
        first_file_path = self._get_numbered_file_path()
        return super().start_recording(first_file_path, include_timestamp)

    def write_batch(self, batch: EEGSampleBatch) -> bool:
        if not self.is_recording:
            return False

        # Проверяем необходимость ротации файла
        current_time = time.time()
        if (self.last_save_time and
                current_time - self.last_save_time >= self.auto_save_interval):
            self._rotate_file()

        return super().write_batch(batch)

    def _rotate_file(self):
        if not self.is_recording:
            return

        try:
            # Закрываем текущий файл
            if self.file_handle:
                self._write_final_stats()
                self.file_handle.close()

            # Создаем новый файл
            self.file_counter += 1
            new_file_path = self._get_numbered_file_path()

            # Открываем новый файл
            self.file_handle = open(new_file_path, 'w', newline='', encoding='utf-8')
            self.csv_writer = csv.writer(self.file_handle)

            # Записываем заголовок и метаданные
            header = self._create_header(True)
            self.csv_writer.writerow(header)
            self._write_metadata()

            self.file_path = new_file_path
            self.last_save_time = time.time()

            print(f"Файл ротирован: {new_file_path}")

        except Exception as e:
            self.error_occurred.emit(f"Ошибка ротации файла: {e}")

    def _get_numbered_file_path(self) -> str:
        if not self.base_file_path:
            return "recording.csv"

        # Разделяем путь и расширение
        path_without_ext, ext = os.path.splitext(self.base_file_path)

        # Добавляем номер файла
        return f"{path_without_ext}_{self.file_counter:03d}{ext}"
